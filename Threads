#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>
#include <string.h>

typedef struct vet{
	int *vetor;
	int  **vetor_t;
	int top;
	int top_sub ;
	int *resto ;
	int top_resto ;

}arq;

int num_threads;

void * bubble_sort(void *vett){

	arq vet = (arq)vett;

	//variável auxiliar
	int proximo = 0;

	//varre todo o vetor externo
	for(int i = 0; i < vet.top_sub; i++){
		//trabalha com os próximos elementos
		for(int j = 0; j < (vet.top_sub - 1); j++){
			//Ocorre a troca
	        if(vet.vetor_t[j] > vet.vetor_t[j+1]){
	        	proximo = vet.vetor_t[][j];// selecionar vetores 
	        	vet.vetor_t[j] = vet.vetor_t[j+1];
	        	vet.vetor_t[j+1]=proximo;
	        }
	    }
	 }
}


arq leitura(int argc,char *argv[]){

	int num_threads = atoi(argv[1]);
    FILE *fp[argc-4];
    int n_atual, cont_num = 0;
    int cont_arq = argc-4;
    arq vet ;
	vet.top = 0;

    int j = cont_arq*1000;
	vet.vetor = (int *)malloc (j*sizeof(int));

    vet.vetor[j];
	

    printf("args:%d  ultimo arg: %s",argc,argv[argc-1]);
    printf("  .txt %d\n",cont_arq);
	printf("num_threadS: %d\n",num_threads);
    
    for(int c = 0;c<cont_arq;c++){
        fp[c] = fopen(argv[c+2],"r");
        if(fp[c]==NULL)
            printf("arquivo vazio\n");
        else        
            while(fscanf(fp[c],"%d",&n_atual)!=EOF){//le os arquivos e salve em um unico vetor
                vet.vetor[cont_num] = n_atual;
                cont_num++;// faz a contagem do top numeros lidos
            }vet.top = cont_num;

        fclose(fp[c]);
    }

    return vet;
}
void escreve(arq desord,char * argv){
    FILE * saida;
    saida = fopen(argv,"w");
    for(int k = 0; k< num_threads;k++)
		for(int c =0; c<desord.top_sub;c++)
    fprintf(saida,"%d\n",desord.vetor[c]);

}

void separa_vet(arq vet){

	if(vet.top % num_threads == 0){  // verifica se é posivel a divisao do vetor pela quantidade de threads
		vet.top_sub = vet.top/num_threads;
		vet.vetor_t = (int **)malloc (num_threads*sizeof(int*));
		for(int c = 0;c < num_threads;c++)
			vet.vetor_t[c] = (int *)malloc (vet.top_sub*sizeof(int));
	}	

	else{
		int c = 0;
		int cont_num = vet.top;
		while(cont_num % num_threads != 0){
			vet.resto[c++] = vet.top % num_threads;
			cont_num--;
		}vet.top_resto = c;
		vet.top_sub = cont_num/num_threads;

		vet.vetor_t = (int **)malloc (num_threads*sizeof(int*));

		for(int c = 0;c < num_threads-1;c++)
			vet.vetor_t[c] = (int *)malloc (vet.top_sub*sizeof(int));

		vet.vetor_t[num_threads]= (int *)malloc ((vet.top_sub + vet.top_resto)*sizeof(int));
	}
	int cont = 0;
	int j =0;
	int c = 0;
	int l = 0;
	int top = vet.top_sub;
		for(int k = 0; k< vet.top;k++){
			if(k == top){
				c++;
				top += vet.top_sub;
				l = 0;
			}
			vet.vetor_t[c][l] = vet.vetor[j];
			j++;
			l++;
		}

}

int main(int argc, char *argv[]){


    arq desord;

    desord = leitura(argc,argv);
	pthread_t tid[num_threads];
	

	desord.top_sub = 0;
	desord.resto = 0;
	desord.top_resto = 0;
	separa_vet(desord);

	free(desord.vetor);

	for(int c  =0; c<num_threads;c++)
		pthread_create(&tid[c],NULL,bubble_sort,(void*)desord);

	for(int c  =0; c<num_threads;c++)
		pthread_join(tid[c],NULL);	
	
    escreve(desord,argv[argc-1]);

	free(desord.vetor_t);

    return 0;
}
